<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RIALO — Red Light / Green Light Runner</title>
<meta name="description" content="RIALO Red-Light/Green-Light mini game" />
<style>
  :root{ --bg:#071025; --panel:#0c1320; --accent:#7c5cff; --muted:#9aa4b2; }
  *{box-sizing:border-box}
  body{margin:0; font-family:Inter,system-ui,Arial; background:linear-gradient(180deg,#020417,#071025); color:#eaf0ff; display:flex; justify-content:center; padding:24px;}
  .wrap{width:100%;max-width:1100px}
  header{display:flex;align-items:center;gap:12px;margin-bottom:14px}
  .logo{width:64px;height:64px;border-radius:12px;overflow:hidden;flex:0 0 64px}
  .logo img{width:100%;height:100%;object-fit:cover;display:block}
  h1{font-size:20px;margin:0}
  .lead{color:var(--muted);font-size:13px;margin:0}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:14px;padding:14px;box-shadow:0 10px 40px rgba(0,0,0,0.6);display:grid;grid-template-columns:1fr 320px;gap:14px}
  #gameStage{width:100%;height:520px;border-radius:10px;background:#061026;display:block}
  .side{padding:6px}
  .stat{display:flex;justify-content:space-between;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:8px;font-size:14px}
  .btn{display:inline-block;padding:8px 12px;border-radius:10px;background:var(--accent);color:#fff;text-decoration:none;font-weight:600;cursor:pointer}
  .mutebtn{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px;font-size:13px;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  ul.leader{list-style:none;padding:0;margin:8px 0 0 0}
  ul.leader li{padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-bottom:6px;font-size:13px;display:flex;justify-content:space-between}
  .signal{width:120px;height:120px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:24px}
  .signal.red{background:#ff5c5c;color:#350000}
  .signal.green{background:#6ee7b7;color:#043018}
  @media (max-width:920px){ .card{grid-template-columns:1fr} #gameStage{height:360px} .side{order:2} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo"><img id="logoImg" src="/assets/rialo-logo.png" alt="RIALO Logo" /></div>
    <div>
      <h1>RIALO — Red/Green Runner</h1>
      <p class="lead">Move on GREEN. Freeze on RED. Collect tokens, avoid being caught.</p>
    </div>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <a class="btn" id="visitRialo" href="https://x.com/rialo" target="_blank" rel="noopener">Visit RIALO</a>
    </div>
  </header>

  <div class="card">
    <div>
      <canvas id="gameStage" width="1000" height="520"></canvas>
      <div style="margin-top:10px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <div class="small">Controls: ← → or A/D to walk, hold to run (Shift). On mobile: tap right side to move, left to stop.</div>
        <div style="flex:1"></div>
        <div class="small">Game: <strong id="modeLabel">Idle</strong></div>
      </div>
    </div>

    <aside class="side">
      <div class="stat"><div>Score</div><div id="score">0</div></div>
      <div class="stat"><div>Collected</div><div id="collected">0</div></div>
      <div class="stat"><div>Round</div><div id="round">1</div></div>

      <div style="margin-top:8px">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
          <button id="startBtn" class="btn">Start</button>
          <button id="pauseBtn" class="mutebtn">Pause</button>
        </div>

        <div style="margin:8px 0">
          <div style="margin-bottom:8px;font-weight:700">Signal</div>
          <div id="signalBox" class="signal green">GREEN</div>
        </div>
      </div>

      <hr style="border:none;height:12px"/>

      <div style="font-weight:700;margin-bottom:6px">Local Leaderboard</div>
      <ul class="leader" id="leaderboard"></ul>

      <div style="margin-top:10px" class="small">
        Replace assets in <code>/game/assets/</code>. See instructions below.
      </div>
    </aside>
  </div>

  <footer style="margin-top:12px;color:#9aa4b2;font-size:13px">
    Tip: The game stores top scores in your browser. Use your GitHub repo to serve assets at <code>/game/assets/</code>.
  </footer>
</div>

<script>
/* Red/Green Runner - single-file
   Assets to replace:
     /game/assets/bg.jpg         (background image wide)
     /game/assets/logo-bg.png    (logo background or avatar)
     /game/assets/rialo-logo.png (square logo)
     /game/assets/player.png     (player sprite single image)
     /game/assets/token.png      (collectible)
     /game/assets/catcher.png    (red-catcher)
   Filenames must match exactly (or change paths below).
*/

(function(){
  // config (change if you store elsewhere)
  const ASSET_PATH = '/game/assets/';
  const ASSETS = {
    bg: ASSET_PATH + 'bg.jpg',
    logo: ASSET_PATH + 'rialo-logo.png',
    player: ASSET_PATH + 'player.png',
    token: ASSET_PATH + 'token.png',
    catcher: ASSET_PATH + 'catcher.png'
  };

  // DOM
  const canvas = document.getElementById('gameStage');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const scoreEl = document.getElementById('score');
  const collectedEl = document.getElementById('collected');
  const roundEl = document.getElementById('round');
  const leaderEl = document.getElementById('leaderboard');
  const modeLabel = document.getElementById('modeLabel');
  const signalBox = document.getElementById('signalBox');

  // state
  let W = canvas.width, H = canvas.height;
  let running=false, paused=false, frame=0;
  let score=0, collected=0, round=1;
  let player = { x:120, y:H-140, w:54, h:80, vx:0, speed:3, runningMul:1.6, moving:false };
  let objects = []; // tokens and obstacles
  let signal = 'green'; // 'green' or 'red' - when 'red', player must stop
  let signalTimer = 0, signalDuration = 180; // frames
  let phaseFrames = 0;
  let images = {};

  // load images
  const imgList = Object.values(ASSETS);
  let loaded = 0;
  imgList.forEach(src=>{
    const img = new Image();
    img.src = src;
    img.onload = ()=>{ loaded++; images[src]=img; }
    img.onerror = ()=>{ loaded++; images[src]=null; }
  });

  // helpers
  function setSignal(s){
    signal = s;
    signalBox.className = 'signal ' + (s==='red' ? 'red' : 'green');
    signalBox.textContent = s.toUpperCase();
  }

  function reset(){
    score=0; collected=0; round=1; frame=0; objects=[]; player.x=120;
    updateHUD();
    setSignal('green');
    modeLabel.textContent='Ready';
  }

  function start(){
    if(running) return;
    running=true; paused=false; frame=0; signalTimer=0; phaseFrames=0;
    objects=[]; player.x=120; player.vx=0; player.moving=false;
    modeLabel.textContent='Playing';
    requestAnimationFrame(loop);
  }

  function togglePause(){
    if(!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if(!paused) requestAnimationFrame(loop);
  }

  function endGame(reason){
    running=false;
    saveScore();
    modeLabel.textContent = 'Game Over';
    setTimeout(()=>{ alert('Game Over: '+reason + '\\nScore: '+score); }, 200);
  }

  // spawn tokens and occasional catcher obstacles
  function spawn(){
    // spawn token
    if(Math.random() < 0.04 + round*0.002){
      objects.push({
        type:'token',
        x: W + 40,
        y: H - 140 - Math.random()*120,
        w: 36, h:36,
        vx: - (2 + round*0.3)
      });
    }
    // spawn catcher sometimes (moves when signal turns red)
    if(Math.random() < 0.008 + round*0.0008){
      objects.push({
        type:'catcher',
        x: W + 40,
        y: H - 140,
        w: 72, h:90,
        vx: - (1.6 + round*0.4),
        activeOnRed: true
      });
    }
  }

  function update(){
    frame++; phaseFrames++;

    // signal logic: alternate green/red but with variable durations
    if(phaseFrames > signalDuration){
      phaseFrames = 0;
      // switch
      if(signal === 'green'){
        setSignal('red');
        signalDuration = 80 + Math.floor(Math.random()*120); // red shorter
      } else {
        setSignal('green');
        signalDuration = 160 + Math.floor(Math.random()*200); // green longer early
      }
    }

    // spawn
    spawn();

    // player movement: allowed only when signal is green
    if(player.moving && signal==='green'){
      const sp = player.speed * (player.running ? player.runningMul : 1);
      player.x += sp;
    }
    // small friction if not moving
    player.x = Math.max(20, Math.min(W - player.w - 20, player.x));

    // update objects
    for(let i=objects.length-1;i>=0;i--){
      const o = objects[i];
      o.x += o.vx;
      // collisions
      if(collide(player, o)){
        if(o.type === 'token'){
          collected++; score += 10; objects.splice(i,1);
        } else if(o.type === 'catcher'){
          // if caught while moving during RED -> game over
          if(signal === 'red' && player.moving){
            endGame('Caught by catcher while moving on RED');
            return;
          } else {
            // harmless otherwise (you can push it)
            score += 2;
            objects.splice(i,1);
          }
        }
      } else if(o.x + o.w < -50){
        objects.splice(i,1);
      }
    }

    // penalty if moving during RED - gradually detect and end if moving too much
    if(signal === 'red' && player.moving){
      // small grace: if player moves while red more than threshold -> lose
      if(phaseFrames > 30){ // after 30 frames of red while moving -> lose
        endGame('Moved during RED for too long');
        return;
      }
    }

    // progress: increase round slowly
    if(frame % 1800 === 0){ round++; roundEl.textContent = round; }
    updateHUD();
  }

  function collide(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function render(){
    // background
    ctx.clearRect(0,0,W,H);
    // draw bg image if available
    const bgImg = images[ASSETS.bg];
    if(bgImg){
      // fill with image scaled
      ctx.drawImage(bgImg, 0, 0, W, H);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(0,0,W,H);
    } else {
      ctx.fillStyle = '#061026';
      ctx.fillRect(0,0,W,H);
    }

    // ground stripe
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(0, H-120, W, 120);

    // objects
    objects.forEach(o=>{
      if(o.type === 'token'){
        const tImg = images[ASSETS.token];
        if(tImg) ctx.drawImage(tImg, o.x, o.y, o.w, o.h);
        else { ctx.fillStyle='#ffd166'; roundRect(ctx,o.x,o.y,o.w,o.h,6,true); ctx.fillStyle='#8a5c00'; ctx.fillText('R', o.x+o.w/2-6, o.y+o.h/2+6); }
      } else if(o.type === 'catcher'){
        const cImg = images[ASSETS.catcher];
        if(cImg) ctx.drawImage(cImg, o.x, o.y - (o.h - 90), o.w, o.h);
        else { ctx.fillStyle='#ff5c5c'; roundRect(ctx,o.x,o.y - (o.h - 90),o.w,o.h,8,true); }
      }
    });

    // draw player (sprite if available)
    const pImg = images[ASSETS.player];
    if(pImg){
      ctx.drawImage(pImg, player.x, player.y - player.h, player.w, player.h);
    } else {
      ctx.fillStyle = '#7c5cff';
      roundRect(ctx, player.x, player.y - player.h, player.w, player.h, 10, true);
      ctx.fillStyle='#fff'; ctx.fillText('P', player.x+player.w/2-6, player.y - player.h/2+6);
    }

    // HUD overlay (small)
    ctx.fillStyle='rgba(0,0,0,0.25)';
    ctx.fillRect(12,12,190,48);
    ctx.fillStyle='#fff'; ctx.font='14px Inter, Arial';
    ctx.fillText('Score: '+score, 22, 34);
    ctx.fillText('Round: '+round, 22, 52);
  }

  function loop(){
    if(!running || paused) return;
    update();
    render();
    requestAnimationFrame(loop);
  }

  // input handling
  const keys = {};
  window.addEventListener('keydown',(e)=>{
    if(e.key === 'ArrowRight' || e.key === 'd') { player.moving = true; player.running = e.shiftKey; }
    if(e.key === 'ArrowLeft' || e.key === 'a') { player.moving = true; player.running = e.shiftKey; player.vx = -1; }
  });
  window.addEventListener('keyup',(e)=>{
    if(['ArrowRight','d','ArrowLeft','a'].includes(e.key)) { player.moving = false; player.running = false; }
  });

  // mobile tap controls on canvas
  canvas.addEventListener('touchstart', (ev)=>{
    ev.preventDefault();
    const x = ev.touches[0].clientX - canvas.getBoundingClientRect().left;
    // right half -> move, left half -> stop
    if(x > canvas.width/2) player.moving = true;
    else player.moving = false;
  }, {passive:false});
  canvas.addEventListener('touchend', ()=>{ player.moving = false; });

  // buttons
  startBtn.addEventListener('click', ()=>{ start(); updateLeaderboard(); });
  pauseBtn.addEventListener('click', togglePause);

  // leaderboard local
  function getLB(){ try { return JSON.parse(localStorage.getItem('rialo_rb_lb')||'[]'); } catch(e){ return []; } }
  function saveScore(){
    const name = prompt('Enter name for leaderboard (optional):','anon') || 'anon';
    const lb = getLB();
    lb.push({name:name.slice(0,18), score: score, date: new Date().toISOString()});
    lb.sort((a,b)=>b.score-a.score);
    while(lb.length>10) lb.pop();
    localStorage.setItem('rialo_rb_lb', JSON.stringify(lb));
    updateLeaderboard();
  }
  function updateLeaderboard(){
    const lb = getLB();
    leaderEl.innerHTML = '';
    if(lb.length === 0){ leaderEl.innerHTML = '<li style="opacity:0.6">No scores yet — play now!</li>'; return; }
    lb.slice(0,5).forEach((p,i)=>{ const li=document.createElement('li'); li.innerHTML = `<span>${i+1}. ${escapeHtml(p.name)}</span><span>${p.score}</span>`; leaderEl.appendChild(li); });
  }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // util
  function roundRect(ctx,x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); else ctx.stroke(); }

  function updateHUD(){ scoreEl.textContent = score; collectedEl.textContent = collected; roundEl.textContent = round; }

  // initial
  reset();
  updateLeaderboard();

  // expose for debugging (optional)
  window.RialoRB = { start, reset, setSignal };

  // small autoplay loop to tick signal when not started (visual)
  setInterval(()=>{
    if(!running){
      // alternate visuals slowly
      if(signal === 'green') setSignal('red'); else setSignal('green');
    }
  }, 3000);

})();
</script>
</body>
</html>
